import { render, screen, waitFor } from "@testing-library/react";
import { HydraulicModelBuilder } from "src/__helpers__/hydraulic-model-builder";
import {
  Sel,
  SimulationFinished,
  Store,
  dataAtom,
  fileInfoAtom,
  momentLogAtom,
  simulationAtom,
} from "src/state/jotai";
import { MomentLog } from "src/lib/persistence/moment-log";
import userEvent from "@testing-library/user-event";
import { aTestFile } from "src/__helpers__/file";
import { fMoment } from "src/lib/persistence/moment";
import { aFileInfo, setInitialState } from "src/__helpers__/state";
import { CommandContainer } from "./__helpers__/command-container";
import {
  buildFileSystemHandleMock,
  lastSaveCall,
  stubFileOpen,
  stubFileSave,
} from "src/__helpers__/browser-fs-mock";
import { buildInp } from "src/simulation/build-inp";
import { waitForNotLoading } from "src/__helpers__/ui-expects";
import { getByLabel } from "src/__helpers__/asset-queries";
import { useOpenInpFromFs } from "./open-inp-from-fs";
import { stubUserTracking } from "src/__helpers__/user-tracking";

const aMoment = (name: string) => {
  return fMoment(name);
};

describe("openInpFromFs", () => {
  it("registers in state when the inp was generated by the app", async () => {
    const IDS = { J1: 1 } as const;
    const newHandle = stubFileOpen();
    const store = setInitialState();

    renderComponent({ store });

    const inp = anInpMadeByTheApp({ junctionId: IDS.J1 });
    const file = aTestFile({ filename: "my-network.inp", content: inp });
    await triggerCommand();

    await doFileSelection(file);

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });

    const { hydraulicModel } = store.get(dataAtom);
    expect(getByLabel(hydraulicModel.assets, "1")).toBeTruthy();

    expect(store.get(fileInfoAtom)!.handle).toEqual(newHandle);
    expect(store.get(fileInfoAtom)!.isMadeByApp).toEqual(true);
  });

  it("captures a user tracking events", async () => {
    const userTracking = stubUserTracking();
    stubFileOpen();
    const store = setInitialState();

    renderComponent({ store });

    const inp = minimalInp();
    const file = aTestFile({ filename: "my-network.inp", content: inp });
    await triggerCommand();

    await doFileSelection(file);

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });

    expect(userTracking.capture).toHaveBeenCalledWith({
      name: "openInp.started",
      source: "shortcut",
    });
    expect(userTracking.capture).toHaveBeenCalledWith(
      expect.objectContaining({
        name: "importInp.completed",
      }),
    );
  });

  it("registers in state when the inp was NOT generated by the app", async () => {
    stubFileOpen();
    const store = setInitialState();

    renderComponent({ store });

    const inp = minimalInp({ junctionId: "J1" });
    const file = aTestFile({ filename: "my-network.inp", content: inp });
    await triggerCommand();

    await doFileSelection(file);

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });

    const { hydraulicModel } = store.get(dataAtom);
    expect(getByLabel(hydraulicModel.assets, "J1")).toBeTruthy();

    expect(store.get(fileInfoAtom)!.handle).toEqual(undefined);
    expect(store.get(fileInfoAtom)!.isMadeByApp).toEqual(false);
  });

  it("displays error when cannot process", async () => {
    const userTracking = stubUserTracking();
    stubFileOpen();
    const store = setInitialState({
      hydraulicModel: HydraulicModelBuilder.empty(),
    });
    const file = aTestFile({ content: "INVALID" });

    renderComponent({ store });

    await triggerCommand();

    await doFileSelection(file);

    await waitFor(() =>
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument(),
    );

    expect(screen.getByText(/failed to open model/i)).toBeInTheDocument();
    await userEvent.click(screen.getByText(/understood/i));

    expect(screen.queryByText(/error/i)).not.toBeInTheDocument();
    expect(userTracking.capture).toHaveBeenCalledWith({
      name: "invalidFilesError.seen",
    });
  });

  it("removes previous state", async () => {
    const IDS = { J1: 1, ANY: 2, P1: 3 } as const;
    stubFileOpen();
    const inp = minimalInp({ junctionId: "J1" });
    const previousSimulation: SimulationFinished = {
      status: "failure",
      report: "ERROR",
      modelVersion: "10",
    };
    const previousSelection: Sel = {
      type: "single",
      id: IDS.ANY,
      parts: [],
    };
    const previousMomentLog = new MomentLog();
    const store = setInitialState({
      hydraulicModel: HydraulicModelBuilder.empty(),
      momentLog: previousMomentLog,
      simulation: previousSimulation,
      selection: previousSelection,
      fileInfo: aFileInfo({
        handle: buildFileSystemHandleMock({ fileName: "old.inp" }),
      }),
    });
    const file = aTestFile({ filename: "my-network.inp", content: inp });

    renderComponent({ store });
    await triggerCommand();

    await waitFor(() =>
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument(),
    );
    await waitForNotLoading();
    await userEvent.click(screen.getByRole("button", { name: /discard/i }));
    await waitForNotLoading();
    await doFileSelection(file);

    await waitFor(() =>
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument(),
    );

    const { hydraulicModel, selection } = store.get(dataAtom);
    expect(getByLabel(hydraulicModel.assets, "J1")).toBeTruthy();
    expect(getByLabel(hydraulicModel.assets, "P1")).toBeFalsy();

    const updatedMomentLog = store.get(momentLogAtom);
    expect(updatedMomentLog.id).not.toEqual(previousMomentLog.id);

    const simulation = store.get(simulationAtom);
    expect(simulation.status).toEqual("idle");

    expect(selection.type).toEqual("none");
  });

  it("can save previous changes before opening", async () => {
    const IDS = { J1: 1 } as const;
    stubFileOpen();
    stubFileSave();
    const inp = minimalInp({ junctionId: "J1" });
    const momentLogWithChanges = new MomentLog();
    momentLogWithChanges.append(aMoment("A"), aMoment("B"));
    const store = setInitialState({
      hydraulicModel: HydraulicModelBuilder.with().aJunction(IDS.J1).build(),
      momentLog: momentLogWithChanges,
    });
    const file = aTestFile({ filename: "my-network.inp", content: inp });

    renderComponent({ store });

    await triggerCommand();

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });
    expect(screen.getByText(/unsaved/i)).toBeInTheDocument();

    await userEvent.click(
      screen.getByRole("button", { name: /save and continue/i }),
    );

    await waitForNotLoading();

    const lastSave = lastSaveCall();

    expect(await lastSave.contentBlob.text()).toContain("J1");

    await waitFor(() =>
      expect(screen.queryByText(/unsaved/i)).not.toBeInTheDocument(),
    );
    await waitForNotLoading();
    await doFileSelection(file);

    await waitForNotLoading();

    const { hydraulicModel } = store.get(dataAtom);
    expect(getByLabel(hydraulicModel.assets, "J1")).toBeTruthy();

    expect(store.get(fileInfoAtom)!.handle).toEqual(undefined);
  });

  it("can discard changes when opening a new project", async () => {
    const inp = minimalInp({ junctionId: "J1" });
    const momentLogWithChanges = new MomentLog();
    momentLogWithChanges.append(aMoment("A"), aMoment("B"));
    const store = setInitialState({
      hydraulicModel: HydraulicModelBuilder.empty(),
      momentLog: momentLogWithChanges,
    });
    const file = aTestFile({ filename: "my-network.inp", content: inp });

    renderComponent({ store });

    await triggerCommand();

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });
    expect(screen.getByText(/unsaved/i)).toBeInTheDocument();

    await userEvent.click(screen.getByRole("button", { name: /discard/i }));

    await waitFor(() =>
      expect(screen.queryByText(/unsaved/i)).not.toBeInTheDocument(),
    );
    await doFileSelection(file);

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });

    const { hydraulicModel } = store.get(dataAtom);
    expect(getByLabel(hydraulicModel.assets, "J1")).toBeTruthy();
  });
});

it("doesnt create model when coordinates not supported", async () => {
  const inp = inpWithoutCoordinates({ junctionId: "J1" });
  const store = setInitialState({
    hydraulicModel: HydraulicModelBuilder.empty(),
  });
  const file = aTestFile({ filename: "my-network.inp", content: inp });

  renderComponent({ store });

  await triggerCommand();

  await doFileSelection(file);

  await waitFor(() => {
    expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
  });

  expect(screen.getByText(/coordinates missing/i)).toBeInTheDocument();

  await userEvent.click(screen.getByRole("button", { name: /understood/i }));

  expect(screen.queryByText(/coordinates missing/i)).not.toBeInTheDocument();
  const { hydraulicModel } = store.get(dataAtom);
  expect(hydraulicModel.assets.size).toEqual(0);
});

it("shows warning when using unsupported features", async () => {
  const inp = inpWithUnsupportedFeatures({ junctionId: "J1" });
  const store = setInitialState({
    hydraulicModel: HydraulicModelBuilder.empty(),
  });
  const file = aTestFile({ filename: "my-network.inp", content: inp });

  renderComponent({ store });

  await triggerCommand();

  await doFileSelection(file);

  await waitFor(() => {
    expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
  });

  expect(screen.getByText(/not fully supported yet/i)).toBeInTheDocument();

  await userEvent.click(screen.getByRole("button", { name: /understood/i }));

  expect(screen.queryByText(/coordinates missing/i)).not.toBeInTheDocument();
  const { hydraulicModel } = store.get(dataAtom);
  expect(getByLabel(hydraulicModel.assets, "J1")).toBeTruthy();
});

const triggerCommand = async () => {
  await userEvent.click(screen.getByRole("button", { name: "openInpFromFs" }));
};

const doFileSelection = async (file: File) => {
  await userEvent.upload(screen.getByTestId("file-upload"), file);
};

const TestableComponent = () => {
  const openInpFromFs = useOpenInpFromFs();

  return (
    <button
      aria-label="openInpFromFs"
      onClick={() => openInpFromFs({ source: "shortcut" })}
    >
      Open from fs
    </button>
  );
};
const minimalInp = ({
  junctionId = "J1",
}: { junctionId?: string } = {}): string => {
  return `
    [JUNCTIONS]
    ${junctionId}\t10
    [COORDINATES]
    ${junctionId}\t1\t2
    `;
};
const inpWithUnsupportedFeatures = ({
  junctionId = "J1",
}: {
  junctionId?: string;
}): string => {
  return `
    [JUNCTIONS]
    ${junctionId}\t10
    [UNSUPPORTED]
    ANY
    [COORDINATES]
    ${junctionId}\t1\t2
    `;
};

const inpWithoutCoordinates = ({
  junctionId = "J1",
}: {
  junctionId?: string;
} = {}): string => {
  return `
    [JUNCTIONS]
    ${junctionId}\t10
    `;
};

const anInpMadeByTheApp = ({ junctionId }: { junctionId: number }) => {
  const hydraulicModel = HydraulicModelBuilder.with()
    .aJunction(junctionId, { coordinates: [10, 10] })
    .build();
  const inp = buildInp(hydraulicModel, {
    madeBy: true,
    geolocation: true,
  });
  return inp;
};

const renderComponent = ({ store }: { store: Store }) => {
  render(
    <CommandContainer store={store}>
      <TestableComponent />
    </CommandContainer>,
  );
};
